<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />

    <title>APéRé - Notes on code, diy, surf, mountain and more.</title>
    <meta name="description" content="Notes on code, diy, surf, mountain and more." />

    <meta name="HandheldFriendly" content="True" />
    <meta name="MobileOptimized" content="320" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" type="text/css" href="/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
    <!-- Customisation  -->
    <link rel="stylesheet" type="text/css" href="/assets/css/main.css " />

</head>
<body class="home-template">

    <header class="main-header post-head no-cover">
    <nav class="main-nav  clearfix">
        <a class="back-button icon-arrow-left" href="/">Home</a>
        <a class="subscribe-button icon-feed" href="/feed.xml">Subscribe</a>
    </nav>
</header>

<main class="content" role="main">

    <article class="post">

        <header class="post-header">
            <h1 class="post-title">Ocaml Modules In Rust</h1>
            <section class="post-meta">
                
                    on Rust and Ocaml
                
                <time class="post-date" datetime="2020-11-27">27 Nov 2020</time>
            </section>
        </header>

<!--         <header class="post-header">
            <a id="blog-logo" href="http://localhost:4000">
                
                    <img src="true" alt="APéRé" />
                
            </a>
        </header> -->

        <!-- <span class="post-meta">
            <time datetime="2020-11-27">27 Nov 2020</time>
            
                on Rust and Ocaml
            
        </span> -->

        <!-- <h1 class="post-title">Ocaml Modules In Rust</h1> -->

        <section class="post-content">
             <h1>Introduction</h1>
<p>Earlier this year, the covid lockdown gave me the opportunity to take on a long awaited project of
  mine: learning the Ocaml language. Working at Inria, I heard quite a lot about how beautiful a
  language it was, but until then, I did not take the time to get a proper introduction. I spent some
  days going through the <a href="https://dev.realworldocaml.org/">Real World Ocaml</a> book, which not only gave me a broader perspective on the
  language, but more importantly, on functional languages in general. Indeed, <i>Rust</i> was the first
  language with functional features I encountered, and until then, I always felt I missed some
  language features to feel the thrill of functional programming. Now that I learned more about Ocaml,
  I feel like Rust already provides most of the features that makes Ocaml great:</p>
<ul>
  <li>A good typing system with ADTs</li>
  <li>Pattern matching</li>
  <li>Non-mutability by default</li>
  <li>Polymorphism with traits</li>
  <li>&#8230;</li>
</ul>
<p>One thing I really liked about Ocaml, that has no direct equivalent in Rust though, is its <b>module
  system</b>. It is often cited as one of the killer features of Ocaml, and I must say, I really
  enjoyed using it. In constrast with Rust, Ocaml modules have a broader use in the language. While in
  Rust, modules are merely used as namespaces, Ocaml support modules as first-class citizens of the
  language. In essence, Ocaml modules have several benefits:</p>
<ul>
  <li>Modules are <i>typed</i>, and their type is called a <i>signature</i>.</li>
  <li>Modules can be treated as <i>values</i> of a given <i>signature</i>.</li>
  <li>Multiple modules of the same signature can exist at the same time.</li>
  <li>Modules values can be manipulated thanks to module-level functions named <i>Functors</i>.</li>
</ul>
<p>Lately I was working on a project in Rust, involving benchmarking different implementations of the
  same module. To make it work, I tried different variations of the same pattern. First, I implemented
  the same public interface in two modules:</p>
<div class="highlight"><pre><span></span><span class="c1">// In fast.rs</span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">MyInputStruct</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// some fields</span>
<span class="p">}</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">MyOutputStruct</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// some fields</span>
<span class="p">}</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">MyFunc</span><span class="p">(</span><span class="n">input</span>: <span class="nc">MyStruct</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">MyOutputStruct</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// some faster logic.</span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// Other private stuffs...</span>

<span class="c1">// In slow.rs</span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">MyInputStruct</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// some fields</span>
<span class="p">}</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">MyOutputStruct</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// some fields</span>
<span class="p">}</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">MyFunc</span><span class="p">(</span><span class="n">input</span>: <span class="nc">MyStruct</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">MyOutputStruct</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Some slower logic</span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// Other private stuffs</span>
</pre></div>
<p>Then, in the parent module, I used feature-flags to conditionally import one of the two
  implementations:</p>
<div class="highlight"><pre><span></span><span class="cp">#[cfg(feature=</span><span class="s">&quot;fast-implem&quot;</span><span class="cp">)]</span><span class="w"></span>
<span class="k">mod</span> <span class="nn">fast</span><span class="p">;</span><span class="w"></span>
<span class="cp">#[cfg(feature=</span><span class="s">&quot;fast-implem&quot;</span><span class="cp">)]</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">fast</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">imp</span><span class="p">;</span><span class="w"></span>
<span class="cp">#[cfg(not(feature=</span><span class="s">&quot;fast-implem&quot;</span><span class="cp">))]</span><span class="w"></span>
<span class="k">mod</span> <span class="nn">slow</span><span class="p">;</span><span class="w"></span>
<span class="cp">#[cfg(not(feature=</span><span class="s">&quot;fast-implem&quot;</span><span class="cp">))]</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">slow</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">imp</span><span class="p">;</span><span class="w"></span>
<span class="c1">// Do stuffs with imp</span>
</pre></div>
<p>This seem to be a rather common pattern in <i>Rust</i>, though it can be implemented slightly differently
  depending on the tastes of the developper. Problem is, this kind of polymorphism has several
  drawbacks, the main being that the interface that must be implemented by the different modules is
  never explicited anywhere. Iterating over the code can quickly lead to change in this interface, and
  it can be complicated to keep it coherent and well implemented in all submodules.</p>
<p>This situations reminded me a lot of the ocaml modules,</p>
<p>To do that, I used feature flags which allowed me to switch between different
  implementations. Despite the fact that this works well, it</p>
<p>While learning about Ocaml, I discovered one of its killer feature, namely its <b>module system</b>.</p>
<p>is right to say that it gives a very neat way to express</p>
<p>gave me the opportunity to learn more about the famous ocaml langua
  From my perspective, Ocaml is a particularly well designed language. Though I have not been able to
  use it a lot over the past years,
  Lately, I&#8217;ve been working on a project involving different implementations of the same module
  interface in <code>Rust</code>.One thing that makes it beautiful
  is its module system. This module system allows three very interesting things:</p>
<ul>
  <li>Declare module <b>signatures</b>, which can be seen as module types.</li>
  <li>Implement module <b>signatures</b>, with concrete modules exposing the types and functions of the
    signature.</li>
  <li>Treat modules as values, allowing to apply special functions to it, named <b>Functors</b>.</li>
</ul>
<p>This set of feature is incredibly powerful and allows</p>
<ul>
  <li>To clearly separate responsibilities in the program thanks to precise interfaces (the signatures)</li>
  <li>To use different implementations of the same</li>
</ul>
<p>In oop, people tend to use interfaces to define the expected behavior of a class. This is pretty
  close to the signature feature of the ocaml module system, but ocaml allows something that very few
  (if any) language is able to do: define interfaces over multiple types at once. In essence, the
  ocaml module system extends the usual oop interfacing facilities to allow to specify the expected
  behavior of multiple types at the same time, and the way they are related.</p>
<h1>A tour of modules in Ocaml</h1>
<h2>Defining a module signature</h2>
<div class="highlight"><pre><span></span><span class="c">(* This is a type signature, or a module type if you prefer :) *)</span>
<span class="k">module</span> <span class="k">type</span> <span class="nc">MyModuleSig</span> <span class="o">=</span> <span class="k">sig</span>
  <span class="c">(* The implementor must expose a type named `t` in its public interface *)</span>
  <span class="k">type</span> <span class="n">t</span>
  <span class="c">(* The implementor must expose a type named `b` in its pubnlic interface *)</span>
  <span class="k">type</span> <span class="n">b</span>
  <span class="c">(* The implementor must expose a function that takes the two types and return an integer *)</span>
  <span class="k">val</span> <span class="n">some_func</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">int</span>
  <span class="c">(* The implementor must expose values *)</span>
  <span class="k">val</span> <span class="n">t_init</span><span class="o">:</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">b_init</span><span class="o">:</span> <span class="n">b</span>
<span class="k">end</span>
</pre></div>
<h2>Implementing a module signature</h2>
<div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">Implem1</span><span class="o">:</span> <span class="nc">MyModuleSig</span> <span class="o">=</span> <span class="k">struct</span> <span class="c">(* Note that here the struct keyword denotes a module *)</span>
  <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">int</span>
  <span class="k">type</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">int</span>
  <span class="k">let</span> <span class="n">private_func</span> <span class="n">t</span> <span class="n">b</span> <span class="o">=</span> <span class="n">t</span> <span class="o">+</span> <span class="n">b</span>
  <span class="k">let</span> <span class="n">some_func</span> <span class="o">=</span> <span class="n">private_func</span>
  <span class="k">let</span> <span class="n">t_init</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">let</span> <span class="n">b_init</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">end</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">some_t</span> <span class="o">=</span> <span class="nn">Implem1</span><span class="p">.</span><span class="n">t_init</span>
<span class="k">let</span> <span class="n">some_b</span> <span class="o">=</span> <span class="nn">Implem1</span><span class="p">.</span><span class="n">b_init</span>
<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">Implem1</span><span class="p">.</span><span class="n">some_func</span> <span class="n">some_t</span> <span class="n">some_b</span>
</pre></div>
<h1>Modules in rust</h1>
<div class="highlight"><pre><span></span><span class="cp">#!/usr/bin/env run-cargo-script</span><span class="w"></span>
</pre></div>
<p>Note that a trait with associated type is pretty close to a module signature in the ocaml meaning:</p>
<div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">MyModuleSig</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">T</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">B</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">T_INIT</span>: <span class="nc">Self</span>::<span class="n">T</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">B_INIT</span>: <span class="nc">Self</span>::<span class="n">B</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">some_func</span><span class="p">(</span><span class="n">t</span>: <span class="nc">Self</span>::<span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">b</span>: <span class="nc">Self</span>::<span class="n">B</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="k">mod</span> <span class="nn">my_module</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">T</span><span class="p">(</span><span class="kt">i32</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">B</span><span class="p">(</span><span class="kt">i32</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T_INIT</span>: <span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">B_INIT</span>: <span class="nc">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">some_func</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">b</span>: <span class="nc">B</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">t</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="c1">// This is close to a value module</span>
<span class="k">struct</span> <span class="nc">MyModuleAsSigObject</span><span class="p">;</span><span class="w"></span>
<span class="k">impl</span><span class="w"> </span><span class="n">MyModuleSig</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MyModuleAsSigObject</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_module</span>::<span class="n">T</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_module</span>::<span class="n">B</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">T_INIT</span>: <span class="nc">Self</span>::<span class="n">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_module</span>::<span class="n">T_INIT</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">B_INIT</span>: <span class="nc">Self</span>::<span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_module</span>::<span class="n">B_INIT</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">some_func</span><span class="p">(</span><span class="n">t</span>: <span class="nc">my_module</span>::<span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">b</span>: <span class="nc">my_module</span>::<span class="n">B</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">my_module</span>::<span class="n">some_func</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Now, we re-export the module as implementor of the signature</span>
<span class="k">mod</span> <span class="nn">my_module_as_sig</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="k">super</span>::<span class="p">{</span><span class="n">MyModuleAsSigObject</span><span class="p">,</span><span class="w"> </span><span class="n">MyModuleSig</span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">type</span> <span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">MyModuleAsSigObject</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">MyModuleSig</span><span class="o">&gt;</span>::<span class="n">T</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">type</span> <span class="nc">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">MyModuleAsSigObject</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">MyModuleSig</span><span class="o">&gt;</span>::<span class="n">B</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T_INIT</span>: <span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">MyModuleAsSigObject</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">MyModuleSig</span><span class="o">&gt;</span>::<span class="n">T_INIT</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">B_INIT</span>: <span class="nc">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">MyModuleAsSigObject</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">MyModuleSig</span><span class="o">&gt;</span>::<span class="n">B_INIT</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">some_func</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">b</span>: <span class="nc">B</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">&lt;</span><span class="n">MyModuleAsSigObject</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">MyModuleSig</span><span class="o">&gt;</span>::<span class="n">some_func</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="c1">// The signature of the input module</span>
<span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">InputSig</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">T</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">T_INIT</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">some_func</span><span class="p">(</span><span class="n">t1</span>: <span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="k">mod</span> <span class="nn">input_mod</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">T</span><span class="p">(</span><span class="kt">i32</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T_INIT</span>: <span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">some_func</span><span class="p">(</span><span class="n">t1</span>: <span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">t1</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">t2</span><span class="p">.</span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">InputModObject</span><span class="p">;</span><span class="w"></span>
<span class="k">impl</span><span class="w"> </span><span class="n">InputSig</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">InputModObject</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input_mod</span>::<span class="n">T</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">T_INIT</span>: <span class="nc">Self</span>::<span class="n">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input_mod</span>::<span class="n">T_INIT</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">some_func</span><span class="p">(</span><span class="n">t1</span>: <span class="nc">input_mod</span>::<span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span>: <span class="nc">input_mod</span>::<span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">input_mod</span>::<span class="n">some_func</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">mod</span> <span class="nn">input_mod_as_sig</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="k">super</span>::<span class="p">{</span><span class="n">InputSig</span><span class="p">,</span><span class="w"> </span><span class="n">InputModObject</span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">type</span> <span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">InputModObject</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">InputSig</span><span class="o">&gt;</span>::<span class="n">T</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T_INIT</span>: <span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">InputModObject</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">InputSig</span><span class="o">&gt;</span>::<span class="n">T_INIT</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">some_func</span><span class="p">(</span><span class="n">t1</span>: <span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">&lt;</span><span class="n">InputModObject</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">InputSig</span><span class="o">&gt;</span>::<span class="n">some_func</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="c1">// We declare the output signature</span>
<span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">OutputSig</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">T</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">B</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">T_INIT</span>: <span class="nc">Self</span>::<span class="n">T</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">B_INIT</span>: <span class="nc">Self</span>::<span class="n">B</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">some_func</span><span class="p">(</span><span class="n">t</span>: <span class="nc">Self</span>::<span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">b</span>: <span class="nc">Self</span>::<span class="n">B</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// We declare the functor</span>
<span class="k">struct</span> <span class="nc">FunctorObject</span><span class="o">&lt;</span><span class="n">M</span>: <span class="nc">InputSig</span><span class="o">&gt;</span><span class="p">(</span><span class="n">M</span><span class="p">);</span><span class="w"></span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="w"> </span><span class="n">OutputSig</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">FunctorObject</span><span class="p">(</span><span class="n">M</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">M</span>: <span class="nc">InputSig</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">M</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">InputSig</span><span class="o">&gt;</span>::<span class="n">T</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">M</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">InputSig</span><span class="o">&gt;</span>::<span class="n">T</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">T_INIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">M</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">InputSig</span><span class="o">&gt;</span>::<span class="n">T_INIT</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">B_INIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">M</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">InputSig</span><span class="o">&gt;</span>::<span class="n">T_INIT</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">some_func</span><span class="p">(</span><span class="n">t</span>: <span class="nc">Self</span>::<span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">b</span>: <span class="nc">Self</span>::<span class="n">B</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">&lt;</span><span class="n">M</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">InputSig</span><span class="o">&gt;</span>::<span class="n">some_func</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// We apply the functor</span>
<span class="k">type</span> <span class="nc">OutputModObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FunctorObject</span><span class="p">(</span><span class="n">InputModObject</span><span class="p">);</span><span class="w"></span>

<span class="k">mod</span> <span class="nn">output_mod_as_sig</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="k">super</span>::<span class="p">{</span><span class="n">OutputSig</span><span class="p">,</span><span class="w"> </span><span class="n">OutputModObject</span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">type</span> <span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">OutputModObject</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">OutputSig</span><span class="o">&gt;</span>::<span class="n">T</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">type</span> <span class="nc">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">OutputModObject</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">OutputSig</span><span class="o">&gt;</span>::<span class="n">B</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T_INIT</span>: <span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">OutputModObject</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">OutputSig</span><span class="o">&gt;</span>::<span class="n">T_INIT</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">B_INIT</span>: <span class="nc">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">OutputModObject</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">OutputSig</span><span class="o">&gt;</span>::<span class="n">B_INIT</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">some_func</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">b</span>: <span class="nc">B</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">&lt;</span><span class="n">OutputModObject</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">OutputSig</span><span class="o">&gt;</span>::<span class="n">some_func</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;That&#39;s all functors!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
 
        </section>

        

        <footer class="post-footer">
            <!-- If we want to display author's name and bio -->
            
                <figure class="author-image">
                    <a class="img" href="/" style="background-image: url(/assets/images/profile.jpg)">
                    <span class="hidden">apere's Picture</span></a>
                </figure>
                <section class="author">
                    <!-- Author Name -->
                    <h4> apere </h4>
                    <!-- Author Bio -->
                    <p>
                        Reserach and Development Engineer, currently working on secured machine learning.
                    </p>
                </section>
            

            <!-- Share links section -->
            <section class="share">
    <h4>Share this post</h4>
    <a class="icon-twitter" href="http://twitter.com/share?text=Ocaml Modules In Rust&amp;url=blog.apere.me/rust/ocaml/2020/11/27/ocaml-modules-in-rust.html"
        onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <span class="hidden">Twitter</span>
    </a>
    <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=blog.apere.me/rust/ocaml/2020/11/27/ocaml-modules-in-rust.html"
        onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
        <span class="hidden">Facebook</span>
    </a>
    <a class="icon-google-plus" href="https://plus.google.com/share?url=blog.apere.me/rust/ocaml/2020/11/27/ocaml-modules-in-rust.html"
       onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
        <span class="hidden">Google+</span>
    </a>
</section>

            <!-- Disqus comments -->
            

        </footer>

    </article>

</main>

    <footer class="site-footer clearfix">
      <section class="copyright">
        <a href="">APéRé</a> &copy; 
              2020 &bull; All rights reserved.
      </section>
      <section class="poweredby">Made with Jekyll using 
          <a href="http://github.com/rosario/kasper">Kasper theme</a>,
          <a href="https://www.toptal.com/designers/subtlepatterns/geometry-2/">Subtle Pattern</a>,
          <a href="https://github.com/be5invis/iosevka">Iosevka font</a>
      </section>
    </footer>
    
    <script type="text/javascript" src="/assets/js/jquery-1.11.1.min.js"></script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="/assets/js/index.js"></script>

    <!-- Google Analytics Tracking code -->
    <!-- <script type="text/javascript">

         var _gaq = _gaq || [];
         _gaq.push(['_setAccount', 'UA-XXXXXXXX-X']);
         _gaq.push(['_trackPageview']);

         (function() {
         var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
         ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
         var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
         })();

         </script> -->
</body>
</html>
